# Lua

## 特性
- 小巧的脚本语言，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。
- 面向过程+函数式编程
- 提供 table 实现数组，哈希表，集合，对象
- 内置闭包
- 闭包+table => 面向对象

## 环境搭建

https://github.com/rjpcomputing/luaforwindows/releases

## 01-基本语法

### 注释
单行：--
多行: `--[[blabla]]--`

### 标示符
和其他语言类似，区分大小写，不允许使用特殊字符如 @, $, 和 % 来定义标示符

### 关键词
和其他语言类似，碰到的时候再查。
一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。

### 全局变量
默认情况下，变量总是认为是全局的
全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。


## 02-数据类型

动态类型
8种基本类型：nil、boolean、number（双精度浮点）、string（单引号或双引号）、userdata、function、thread 和 table（关联数组）。

使用 type 函数测试给定变量或者值的类型

### 1. nil
nil 有删除的作用，nil作比较的时候应该加上双引号

### 2. boolean
Lua 把 false 和 nil 看作是 false，其他的都为 true，数字 0 也是 true

### 3. number

### 4. string
字符串使用单引号或者双引号来表示，也可以使用两个方括号来表示

在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字
字符串连接使用的是 `..`

使用 # 来计算字符串的长度，放在字符串前面

### 5. table
在 Lua 里，table 的创建是通过"构造表达式"来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表
在 Lua 里表的默认初始索引一般以 1 开始。

table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。

### 6. function
在 Lua 中，函数是被看作是"第一类值（First-Class Value）"，函数可以存在变量里:

function 可以以匿名函数（anonymous function）的方式通过参数传递:

### 7. thread
在 Lua 里，最主要的线程是协同程序（coroutine）。
它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。
线程可以同时多个运行，而协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停。

### 8. userdata
用户自定义数据，用于表示其他语言中所创建的类型，存储到lua变量中调用


## 03-变量

分为三种：全局，局部，表中的域
默认lua中的变量都是全局变量，除非使用local显式声明为局部变量
局部变量的作用域从声明位置开始到所在语句块结束
变量的默认值都为nil

### 赋值语句

可以对多个变量同时赋值，先计算右边所有的值，然后再执行赋值操作，和 go 差不多

变量和值的数量不同的时候，有两种情况：
a. 变量个数 > 值的个数             按变量个数补足nil
b. 变量个数 < 值的个数             多余的值会被忽略

应该尽可能地使用局部变量，好处：避免命名冲突，访问局部变量的速度比全局变量更快

### 索引

可以使用方括号，也可以使用点，和 C 差不多

## 04-循环

while
for
repeat...until

和其他语言差不多，注意一下语法就行


## 05-函数

可以传递函数（类似于回调），允许多返回值

用三个点表示可变参数（类似于java）
可以通过 select("#",...) 来获取可变参数的数量
select(n, ...) 表示在可变参数中，第n位右边的参数列表

## 06-运算符
### 算术运算符

// 表示整除

### 关系运算符

~= 表示不等于

### 逻辑运算符
and
or
not

### 其他运算符

`..` 连接字符串
`#` 一元运算符，返回字符串或表的长度

### 运算符的优先级
和其他语言类似

## 07-字符串

string.sub()用于截取字符串
string.sub(s, i [, j])

大小写转换： upper，lower
字符串查找与反转

字符串格式化string.format，和其他语言类似
字符和整数互相转换：string.byte

其他常用函数：string.len，string.rep

匹配模式：string.find, string.gmatch, string.gsub, string.match

## 08-数组

用table实现的

## 09-迭代器

泛型 for 迭代器
无状态的迭代器：避免创建闭包花费额外的代价
每一次迭代，迭代函数都是用两个变量的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素
这种无状态迭代器的典型的例子是ipairs，它遍历数组的每一个元素，元素的索引需要的是数值

多状态的迭代器
很多情况下，迭代器需要保存多个状态信息，而不是简单的状态变量和控制变量，最简单的方法是使用闭包，还有一种方法就是将所有的状态信息封装到table内，将table作为迭代器的状态常量，因为这种情况下可以将所有的信息存放在table内，所有迭代函数通常不需要第二个参数。

## 10-table

Lua也是通过table来解决模块（module）、包（package）和对象（Object）的。 例如string.format表示使用"format"来索引table string。

table连接

## 11-模块与包

lua5.1开始，加入了标准的模块管理机制，可以把一些公用的代码放在一个文件里，以API接口的形式在其他地方调用，有利于代码的重用和降低代码耦合度

lua的模块是由变量、函数等已知元素组成的table，因此创建一个模块很简单，就是创建一个table，然后把需要导出的常量、函数放入其中，最后返回这个table就行。

require函数

加载机制：
require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA_PATH 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化。

## 12-元表（不熟）
metatable

在lua table中我们可以访问对应的key来得到value值，但是却无法对两个value进行操作（比如相加）
metatable允许我们改变table的行为，每个行为关联了对应的元方法。

相加步骤：先检查两者之一是否有元素，之后检查是否有一个叫 __add 的字段，若找到，则调用对应的值，__add等即时字段，其对应的值（往往就是一个函数或是table）就是“元方法”
有两个很重要的函数来处理元表

```lua
mytable = {}                          -- 普通表
mymetatable = {}                      -- 元表
setmetatable(mytable,mymetatable)     -- 把 mymetatable 设为 mytable 的元表
```
等同于
```
mytable = setmetatable({},{})
```

__index元方法
metatable最常用的键，当通过键来访问table的时候，如果这个键没有值，那么lua就会寻找该table的metatable中的__index键，如果__index包含一个表格，lua会在表格中查找相应的键


## 13-协同程序（不熟）
拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其他协同程序共享全局变量和其他大部分东西。
在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起
协同程序有点类似于同步的多线程，在等待同一个线程锁的几个线程有点类似协同。

基本语法：
create
resume
yield
status
wrap         返回一个函数，一旦调用这个函数，就进入coroutine，和create功能重复
running      返回正在跑的coroutine，一个coroutine就是一个线程，当使用running的时候，就返回一个coroutine的线程号


## 14-文件I/O
简单模式：类似于C
完全模式：使用外部的文件句柄来实现，以一种面向对象的形式，将所有的文件操作定义为文件句柄的方法

## 15-错误处理
语法错误
运行错误

使用assert和error来处理错误

## 16-调试（不熟）

lua本身并未内置调试器，但很多开发者共享了他们的lua调试器代码。

## 17-垃圾回收

Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。

## 18-面向对象（不熟）

使用table描述对象的属性
使用metatable模拟继承

